# [ allow ( warnings ) ] fn _oasis_dispatcher ( ) { use oasis_std :: { Service as _ , reexports :: serde :: Deserialize } ; # [ derive ( Deserialize ) ] # [ serde ( tag = "method" , content = "payload" ) ] enum RpcPayload { set_user_contract_address ( ( String , String , ) ) , get_user_contract_address ( ( String , ) ) } let ctx = oasis_std :: Context :: default ( ) ; let mut service = < Router > :: coalesce ( ) ; let input = oasis_std :: backend :: input ( ) ; let payload : RpcPayload = oasis_std :: reexports :: serde_cbor :: from_slice ( & input ) . unwrap ( ) ; let output : std :: result :: Result < Vec < u8 > , Vec < u8 > > = match payload { RpcPayload :: set_user_contract_address ( ( usedid , contractId , ) ) => { let output = match service . set_user_contract_address ( & ctx , usedid , contractId ) { Ok ( output ) => Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & output ) . unwrap ( ) ) , Err ( err ) => Err ( oasis_std :: reexports :: serde_cbor :: to_vec ( & err ) . unwrap ( ) ) , } ; < Router > :: sunder ( service ) ; output } RpcPayload :: get_user_contract_address ( ( usedid , ) ) => { let output = match service . get_user_contract_address ( & ctx , usedid ) { Ok ( output ) => Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & output ) . unwrap ( ) ) , Err ( err ) => Err ( oasis_std :: reexports :: serde_cbor :: to_vec ( & err ) . unwrap ( ) ) , } ; < Router > :: sunder ( service ) ; output } } ; match output { Ok ( output ) => oasis_std :: backend :: ret ( & output ) , Err ( err_output ) => oasis_std :: backend :: err ( & err_output ) , } }