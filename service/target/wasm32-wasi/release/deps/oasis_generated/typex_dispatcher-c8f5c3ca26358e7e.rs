# [ allow ( warnings ) ] fn _oasis_dispatcher ( ) { use oasis_std :: { Service as _ , reexports :: serde :: Deserialize } ; # [ derive ( Deserialize ) ] # [ serde ( tag = "method" , content = "payload" ) ] enum RpcPayload { register_param ( ( Vec < String > , ) ) , get_param ( ) , insert_user ( ( String , ) ) , batch_insert_user ( ( Vec < String > , ) ) , get_user_contract_address ( ( String , ) ) , prepare_assumption_data ( ) , register_user ( ( String , ) ) , get_all_users ( ) , get_proof ( ( String , ) ) } let ctx = oasis_std :: Context :: default ( ) ; let mut service = < TypeX > :: coalesce ( ) ; let input = oasis_std :: backend :: input ( ) ; let payload : RpcPayload = oasis_std :: reexports :: serde_cbor :: from_slice ( & input ) . unwrap ( ) ; let output : std :: result :: Result < Vec < u8 > , Vec < u8 > > = match payload { RpcPayload :: register_param ( ( public_parameters , ) ) => { let output = match service . register_param ( & ctx , public_parameters ) { Ok ( output ) => Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & output ) . unwrap ( ) ) , Err ( err ) => Err ( oasis_std :: reexports :: serde_cbor :: to_vec ( & err ) . unwrap ( ) ) , } ; < TypeX > :: sunder ( service ) ; output } RpcPayload :: get_param ( ) => { Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & service . get_param ( & ctx , ) ) . unwrap ( ) ) } RpcPayload :: insert_user ( ( usedid , ) ) => { let output = match service . insert_user ( & ctx , usedid ) { Ok ( output ) => Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & output ) . unwrap ( ) ) , Err ( err ) => Err ( oasis_std :: reexports :: serde_cbor :: to_vec ( & err ) . unwrap ( ) ) , } ; < TypeX > :: sunder ( service ) ; output } RpcPayload :: batch_insert_user ( ( usedids , ) ) => { let output = match service . batch_insert_user ( & ctx , usedids ) { Ok ( output ) => Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & output ) . unwrap ( ) ) , Err ( err ) => Err ( oasis_std :: reexports :: serde_cbor :: to_vec ( & err ) . unwrap ( ) ) , } ; < TypeX > :: sunder ( service ) ; output } RpcPayload :: get_user_contract_address ( ( usedid , ) ) => { let output = match service . get_user_contract_address ( & ctx , usedid ) { Ok ( output ) => Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & output ) . unwrap ( ) ) , Err ( err ) => Err ( oasis_std :: reexports :: serde_cbor :: to_vec ( & err ) . unwrap ( ) ) , } ; < TypeX > :: sunder ( service ) ; output } RpcPayload :: prepare_assumption_data ( ) => { let output = match service . prepare_assumption_data ( & ctx , ) { Ok ( output ) => Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & output ) . unwrap ( ) ) , Err ( err ) => Err ( oasis_std :: reexports :: serde_cbor :: to_vec ( & err ) . unwrap ( ) ) , } ; < TypeX > :: sunder ( service ) ; output } RpcPayload :: register_user ( ( usedid , ) ) => { let output = match service . register_user ( & ctx , usedid ) { Ok ( output ) => Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & output ) . unwrap ( ) ) , Err ( err ) => Err ( oasis_std :: reexports :: serde_cbor :: to_vec ( & err ) . unwrap ( ) ) , } ; < TypeX > :: sunder ( service ) ; output } RpcPayload :: get_all_users ( ) => { let output = match service . get_all_users ( & ctx , ) { Ok ( output ) => Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & output ) . unwrap ( ) ) , Err ( err ) => Err ( oasis_std :: reexports :: serde_cbor :: to_vec ( & err ) . unwrap ( ) ) , } ; < TypeX > :: sunder ( service ) ; output } RpcPayload :: get_proof ( ( usedid , ) ) => { let output = match service . get_proof ( & ctx , usedid ) { Ok ( output ) => Ok ( oasis_std :: reexports :: serde_cbor :: to_vec ( & output ) . unwrap ( ) ) , Err ( err ) => Err ( oasis_std :: reexports :: serde_cbor :: to_vec ( & err ) . unwrap ( ) ) , } ; < TypeX > :: sunder ( service ) ; output } } ; match output { Ok ( output ) => oasis_std :: backend :: ret ( & output ) , Err ( err_output ) => oasis_std :: backend :: err ( & err_output ) , } }